#include <vector>
#include <unordered_set>
#include <queue>

using namespace std;

/*
 
 We have to remove one of the initially infected nodes.
 Let says we removed u.
 Now let's check how many nodes can be infected in G/{u}.
 
 Crealy we have to choose the node u, such that the number
 of infected nodes in G\{u} is minimal.
 
 To find the number of infected nodes we can just do a BFS/DFS
 on G/{s}.
 
 Complexity:
 
 - Time: O(k * N^2)
 - Space: O(k * N)
 
 */

class Solution
{
public:
    
    int N;
    int BFS(const int& u, vector<vector<int>>& graph, vector<int>& initial)
    {
        unordered_set<int> visited = {u};
        queue<int> Q;
        
        //search how many nodes can we infect after
        //removing u
        
        for (auto v : initial)
            if (v != u)
            {
                visited.insert(v);
                Q.push(v);
            }
        
        int infected_count = 0;
        while (!Q.empty())
        {
            auto w = Q.front();
            Q.pop();
            
            ++infected_count;
            
            for (int v = 0; v != N; ++v)
                if (v != w && graph[w][v] && !visited.count(v))
                {
                    visited.insert(v);
                    Q.push(v);
                }
        }
        
        return infected_count;
        
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial)
    {
        N = graph.size();
        int current_infected = N;
        int best_to_remove = 0;
        
        //sort(initial.begin(), initial.end());
        
        for (auto u : initial)
        {
            int infected_count = BFS(u, graph, initial);
            
            if (infected_count < current_infected)
            {
                current_infected = infected_count;
                best_to_remove = u;
            }
            else if (infected_count == current_infected && u < best_to_remove)
                best_to_remove = u;
            
        }
        
        return best_to_remove;
        
    }
};
